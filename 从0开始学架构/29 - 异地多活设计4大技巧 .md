# 29 | 异地多活设计4大技巧 

## 笔记

### 1. 保证核心业务的异地多活

假设如图设计用户分区的架构. 通过`Hash`计算用户属于哪个中心. **正常情况下用户属于某个主分区, 每个分区都有其他数据的备份**.

![](./img/29_01.png)

**不是所有的业务都需要异地多活, 鉴别核心业务**

登录才是最核心的业务, 注册和用户信息修改并不一定需要事先异地多活.

```
日活1000万的业务:

1. 登录用户是1000万
2. 注册用户可能是几万
3. 修改用户信息的可能还不到1万
```

登录: 用户在A中心无法登录, 用户在B中心登录

### 2. 保证核心数据最终一致性

异地多活的本质是通过异地的数据冗余, 来保证极端异常的情况下业务也能够正常提供给用户. 

不要陷入完美主义误区, **我要所有数据都实时同步**.

解决方案:

* 尽量减少异地多活机房的距离, 搭建高速网络.
* 尽量减少数据同步, 志不同核心业务先关的数据.
* 保证最终一致性, 不保证实时一致性.

如果在A机房新注册的用户需要5分钟同步到B机房, 此时B机房还没有这个用户的信息, 为了保证业务的正确, B机房就需要根据路由规则到A机房请求数据.

### 3. 采用多种手段同步数据

不要陷入存储误区: **只使用存储系统的同步功能**

同步方式:

* 消息队列方式, 将数据通过消息队列同步到其他业务中心.
* 二次读取方式, 如果本地读取失败, 去对端读取. 
	* B中心没有同步到最新的用户数据, 如果B机房在本地读取失败, 就去远端读取一次.
* 存储系统同步, 通过数据库同步机制同步数据.
* 回源读取, `session`数据之类的, A中心判断`session`属于B, 就去B中心读取`session`数据.
* 重新生成数据方式
	* A中心宕机了, B中心请求`session`数据失败, 此时就只能登陆失败, 让用户重新在B中心登录, 生成新的`session`数据

最终同步方案:

![](./img/29_02.png)

### 4. 只保证绝大部分用户的异地多活

* 密码不同步导致无法登录
* 用户信息不同步导致用户看到旧的信息

不要陷入思维误区: **无法保证100%的业务可用**.

采用多种手段, 保证绝大部分用户的核心业务异地多活.

## 扩展