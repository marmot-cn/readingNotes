#1.2 gcc和vim的使用

[地址](http://www.wyzc.com/play/8704/2972/#12494 "地址")

###笔记

---

**main**

`main函数`: 进程的入口,进程的出口

**C源文件如何到可编译文件**

`.out`: 可执行文件

**C源文件到可执行文件**

1. (`生成.i文件`)预处理(`#`开头预处理解决掉)
	
		gcc -E xxx.c  -o xxx.i
	
2. (`生成.s文件`)编译(翻译成汇编文件)

		gcc -S xxx.i
	
3. (`生成.o文件`)汇编

		gcc -c xxx.s

4. (`生成可执行文件`)连接

		gcc xxx.o -o xxx
 
5. 可执行文件

		./xxx (可执行文件名字 )

**make**

`make` `target`

		make xxx //默认寻找 xxx.c
		
###整理知识点

---


**gcc和make编译**

`gcc`是编译工具.

`make`就是一个`gcc/g++`的`调度器`,通过读入一个文件(默认文件名为Makefile或者makefile),执行`一组`以`gcc/g++`为主的shell命令序列.输入文件主要用来记录文件之间的`依赖关系`和`命令执行顺序`.

####C编译处理阶段

		

		C源程序－>编译预处理－>编译－>优化程序－>汇编程序－>链接程序－>可执行文件

####预处理


预处理是独立于编译器的. 预处理过程读入源代码,检查包含`预处理指令`的语句和`宏定义`,并 对源代码进行响应的转换. 预处理过程还会删除程序中的注释和多余的空白字符.

预处理指令是以`#`号开头的代码行.`#`号必须是该行除了任何空白字符外的`第一个字符`.#后是指令关键字,在关键字和`#`号之间允许存在任意个数的空白字符. 整行语句构成了一条预处理指令,该指令将在编译器进行编译之前对源代码做某些`转换`.

预编译程序所完成的基本上是对源程序的`"替代"`工作.经过此种替代,生成一个没有宏定义、没有条件编译指令、没有特殊符号的输出文件.这个文件的`含义`同没有经过预处理的源文件是`相同`的,但`内容`有所`不同`(`只是简单的替代,无语法检查`).

**指令和用途**

* `#`: 空指令,无任何效果.
* `#include`: 包含一个源代码文件
* `#define`: 定义宏
* `#undef`: 取消已定义的宏
* `#if`: 如果给定`条件`为`真`,则编译下面代码
* `#ifdef`: 如果`宏已经定义`,则编译下面代码
* `#ifndef`: 如果宏没有定义,则编译下面代码
* `#elif`: 如果前面的#if给定条件不为真,当前条件为真,则编译下面代码,其实就是else if的简写
* `#endif`: `结束`一个`#if……#else`条件编译块
* `#error`: 停止编译并显示错误信息

**宏定义指令**

宏定义了一个代表特定内容的`标识符`. 预处理过程会把源代码中出现的宏标识符`替换`成宏定义时的值. 宏最常见的用法是`定义`代表某个值的`全局符号`.宏的第二种用法是定义带参数的宏(`宏函数`),这样的宏可以象函数一样被调用,但它是在调用语句处展开宏,并用调用时的`实际参数`来`代替`定义中的`形式参数`.

* `#define预处理指令`: 用来定义宏, 声明一个标识符, 给出这个标识符代表的代码(易于阅读,容易修改).
			
				#define MAX_NUM 10
				
				int array[MAX_NUM] 
				
* `带参数的#define指令(宏函数)`
		
				#define Cube(x) (x)*(x)*(x)
				
				int num=8+2;
				volume=Cube(num);
				
				展开后为(8+2)*(8+2)*(8+2);
				如果没有括号就变为8+2*8+2*8+2了.
				因为"运算"是要等"编译后" "执行"的时候才会执行的.预处理阶段不会执行"运算"		
	
* `#` 运算符: 出现在宏定义中的`#`运算符`把跟在其后的参数转换成一个字符串`.有时把这种用法的#称为`字符串化运算符`.
	
			#define PASTE(n) "adhfkj"#n
			int main()
			{
      			 printf("%s\n",PASTE(15));
       			 return 0;
			}
			//输出adhfj15
			//宏定义中的#运算符告诉预处理程序,把源代码中任何传递给该宏的参数转换成一个字符串.所以输出应该是adhfkj15.
							
 * `##` 运算符:  ##运算符用于把参数连接到一起. 预处理程序把出现在##两侧的参数`合并成一个符号`.
 	
 			#define NUM(a,b,c) a##b##c
			#define STR(a,b,c) a##b##c
		    int main()
 		    {
       			printf("%d\n",NUM(1,2,3));
       			printf("%s\n",STR("aa","bb","cc"));
       			return 0;
 			}
 
**条件编译指令**
 
程序员可以通过定义不同的宏来决定编译程序对哪些代码进行处理. 条件编译指令将决定那些代码被编译,而哪些是不被编译的.可以根据表达式的值或者某个特定的宏是否被定义来确定编译条件.

*  `#if/#endif/#else/#elif`指令
	* `#if`指令检测跟在制造另关键字后的常量表达式.如果表达式为`真`,则编译后面的代码,直到出现`#else`、`#elif`或`#endif`为止;否则就`不编译`.
	* `#endif`用于终止`#if`预处理指令.
	* `#else`指令用于某个`#if`指令之后,当前面的`#if`指令的条件不为真时,就编译`#else`后面的代码.

			#define DEBUG       //此时#ifdef DEBUG为真
			//#define DEBUG 0  //此时为假
			int main()
			{
   				#ifdef DEBUG
     				printf("Debugging\n");
   				#else
      				printf("Not debugging\n");
   				#endif
   				printf("Running\n");
   				return 0;
			}
			
			#define TWO
			int main()
			{
   				#ifdef ONE
          			printf("1\n");
   				#elif defined TWO
          			printf("2\n");
   				#else
          			printf("3\n");
   				#endif
			}
			#if defined等价于#ifdef; #if !defined等价于#ifndef 

* 防止`重复`包含
			
		//头文件防止重复包含
		//funcA.h
		#ifndef FUNCA_H
		#define FUNCA_H
		//头文件内容
		#end if
		
		如果a.h包含了funcA.h,b.h包含了a.h、funcA.h,重复包含,会出现一些type redefination之类的错误.

**头文件包含指令**

`#include` 预处理指令的作用是在`指令处` `展开` 被包含的文件. 标准C编译器至少支持八重嵌套包含.

 * `#include <xx.h>`: 处理程序在编译器`自带的`或`外部库`的头文件中搜索被包含的头文件.
 * `#include "xx.h"`: 处理程序在当前被编译的`应用程序的源代码`文件中搜索被包含的头文件,如果找不到,再搜索编译器自带的头文件.
         
**特殊符号**

预编译程序可以识别一些特殊的符号. 预编译程序对于在源程序中出现的这些串将用合适的值进行替换.

* `__FILE__`: 包含当前程序文件名的字符串
* `__LINE__`: 表示当前行号的整数
* `__DATE__`: 包含当前日期的字符串
* `__STDC__`: 如果编译器遵循ANSI C标准,它就是个非零值
* `__TIME__`: 包含当前时间的字符串

		printf("%s\n",__FILE__);
		printf("%d\n",__LINE__);
		
* `#error`: 指令将使编译器显示一条错误信息,然后停止编译

		#error error-message

* `#line`: 指令改变`_LINE_`* 与`_FILE_`的内容,它们是在编译程序中预先定义的标识符.

		#line   100          //初始化行计数器 
		#include<stdio.h>    //行号100
		int main()
		{
    		printf("Hello World!\n");
    		printf("%d",__LINE__);
    		return 0;
		}
		//输出104

* `#pragma`: 指令没有正式的定义.编译器可以自定义其用途.典型的用法是禁止或允许某些烦人的警告信息.
	* `#pragma message`: 在编译信息输出窗口中输出相应的信息.
	
			 #pragma message(“消息文本”)
			 当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来.
			 
			  #ifdef _X86
   			  #Pragma message(“_X86 macro activated!”)
   			  #endif 
   			  当我们定义了_X86 这个宏以后,应用程序在编译时就会在编译输出窗口里显示"_X86 macro activated!"
   	* `#pragma code_seg`: 能够设置程序中函数代码存放的代码段(开发驱动程序).
   	* `#pragma once`: 只要在头文件的最开始加入这条指令就能够保证头文件被编译一次.
   	* `#pragma hdrstop`: 表示预编译头文件到此为止,后面的头文件不进行预编译.
	* `#pragma warning`: 该指令允许有选择性的修改编译器的警告消息的行为.
	* `#pragma comment`: 该指令将一个注释记录放入一个对象文件或可执行文件中.
	* `#pragma pack`: 用于内存对齐.

####编译

经过`预处理`得到的输出文件中, 将只有变量,常量,关键字等. 而编译的主要作用是`检查`这些代码的`语法错误`及将这些代码`编译`成为`汇编文件`.

####优化

* 对中间代码的优化,不依赖于具体的计算机. 删除公共表达式,循环优化(代码外提,强度削弱,变换循环控制条件,已知量的合并等),复写传播,以及无用赋值的删除,等等.

		int a,b,c; 
		a = inWord(0x100); /*读取 I/O 空间 0x100 端口的内容存入 a 变量*/ 
		b = a; 
		a = inWord (0x100); /*再次读取 I/O 空间0x100端口的内容存入 a 变量*/ 
		c = a;
		
		优化后(可能):
		
		int a,b,c; 
		a = inWord(0x100); /*读取 I/O 空间 0x100 端口的内容存入 a 变量*/ 
		b = a; 
		c = a;

* 针对目标代码的生成优化,同机器的硬件结构密切相关. 最主要的是考虑是如何充分利用机器的各个硬件寄存器存放的有关变量的值,以减少对于内存的访问次数.

####汇编

汇编过程实际上指把`汇编语言`代码翻译成`目标机器指令`的过程. 目标文件中所存放的也就是与源程序`等效`的目标的`机器语言代码`.

**目标文件**

目标文件由段组成:

* `代码段`: 该段中所包含的主要是程序的指令. 该段一般是可读和可执行的,但一般却不可写.
* `数据段`: 主要存放程序中要用到的各种`全局变量`或`静态`的数据. 一般数据段都是可读,可写,可执行的.

**UNIX环境下的三种类型文件**

* `可重定位文件`
* `共享的目标文件`
* `可执行文件`

`汇编程序`生成`可重定位文件`.


####连接

`由汇编程序生成的目标文件并不能立即就被执行`,需要解决如下问题:

* 某个源文件中的函数可能引用了另一个源文件中定义的某个符号(如变量或者函数调用等)
* 在程序中可能调用了某个库文件中的函数
* ...

链接程序的主要工作就是将`有关的目标文件彼此相连接`,也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来,使得所有的这些目标文件成为一个能够诶操作系统装入执行的统一整体.

**静态连接**

函数的代码将从其所在地静态链接库中被拷贝到最终的可执行程序中. 该程序在被执行时这些代码将被装入到该`进程`的`虚拟地址空间中`. 静态链接库实际上是一个目标文件的`集合`,其中的每个文件含有库中的一个或者一组相关函数的代码.

**动态链接**

函数的代码被放到称作是动态链接库或共享对象的某个目标文件中. 链接程序此时所作的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息. 在此可执行文件被执行时,动态链接库的全部内容将被映射到运行时相应进程的虚地址空间. 动态链接程序将根据可执行程序中记录的信息找到相应的函数代码.



