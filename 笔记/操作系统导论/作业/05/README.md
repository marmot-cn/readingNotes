# README

### 1. 问题

编写一个调用`fork()`的程序。在调用`fork()`之前，让主进程访问一个变量（例如 x）并将其值设为某个值（例如100）。子进程中的变量有什么值？当子进程和父进程都改变x的值，变量会发生什么。

#### 回答

```
gcc q1.c -o q1.out
./q1.out

hello world (pid:12661)
x in parent is 100
x in parent is changed to 300
hello, I am parent of 12662 (pid:12661)
x in child is 100
x in child is changed to 200
hello, I am child (pid:12662)
```


1. 子进程变量的值也是`100`
2. 拥有各自的值

### 2. 问题

编写一个打开文件的程序（使用`open()`系统调用），然后调用 fork() 创建一个新进程。子进程和父进程都可以访问`open()`返回的文件描述符吗？当他们并发（即同时）写入文件时会发生什么。

#### 回答

1. 可以同时访问`open`返回的文件描述符
2. 文件会同时写入父子进程的内容

##### 解释

通过`fork()`创建子进程时，子进程继承父进程环境和上下文的大部分内容的拷贝，其中就包括文件描述符表。

对于父进程在`fork()`之前打开的文件来说，子进程都会继承，与父进程共享相同的文件偏移量。父子进程享有相同的文件偏移量，执行相同的程序读取文件中的字符。程序执行结果是随机的。

### 3. 问题

使用`fork()`编写另一个程序。子进程应打印"hello", 父进程应打印"goodbye"。你应该尝试确保子进程始终先打印。你能否在不调用`wait()`而做到这一点。

#### 解释

* 执行顺序
	* `fork()`： 父子进程的执行次序不确定。
	* `vfork()`：保证子进程先运行,在它调用 exec（进程替换） 或 exit（退出进程）之后父进程才可能被调度运行。
* 地址空间
	* `fork()`： 子进程拷贝父进程的地址空间，子进程是父进程的一个复制品。
	* `vfork()`：子进程共享父进程的地址空间（准确来说，在调用 exec（进程替换） 或 exit（退出进程） 之前与父进程数据是共享的）
