# 读书笔记

## 第一章

### `http.Handler`

利用函数类型也可以拥有自己的方法这个特性巧妙设计出了 http 包的 handlerFunx 类型，这样通过显示转型即可让一个普通函数称为满足 http.Handler 接口的类型。

#### 1. GO 接口

Go 中的接口非常灵活，它是基于 方法集 来实现的，并不是显式声明实现某个接口的类型。也就是说，只要一个类型实现了接口中的所有方法，那么它就自动满足这个接口。

```go
type Handler interface {
    ServeHTTP(w ResponseWriter, r *Request)
}
```

#### 2. 函数类型也可以拥有方法

在 Go 中，虽然函数本身是一个简单的类型，但它也可以拥有方法。

```go
type MyFunc func(w http.ResponseWriter, r *http.Request)
```

虽然 MyFunc 只是一个函数类型，但是我们可以为它定义一个方法 ServeHTTP，这样它就变成了满足 http.Handler 接口的类型：

```
func (f MyFunc) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    f(w, r) // 这里调用 MyFunc 类型的函数
}
```

#### 3. http.HandlerFunc 的实现

http.HandlerFunc 本质上是一个函数类型，并且它实现了 http.Handler 接口。

```
type HandlerFunc func(ResponseWriter, *Request)

func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
```

#### 4. type xx func 作用

* type xxx func 语法用于定义函数类型别名。
* 它使得代码更具可读性和灵活性，尤其是在函数签名复杂或需要复用时。
* 函数类型也可以有方法，这使得函数类型可以像普通类型一样进行扩展

### goroutine 栈模型从分段栈(segmented stack) 改为连续栈(continguous stack), 改善 Hot stack split 问题

#### 1. 分段栈（Segmented Stack）

goroutine 的栈被分成多个 栈段，这些栈段可以按需扩展。这意味着：

* 每个栈段都有一个固定的大小，通常为几 KB。
* 当栈空间不足时，新的栈段会被分配和链接到现有的栈上。
* 栈的扩展是通过 分配新的栈段 实现的，可能会引发内存分配和指针重定向等操作。

问题

* Hot stack split：频繁的栈扩展操作会导致性能下降。因为每次扩展时，必须分配新的栈段并重新分配内存，可能会引发内存碎片化，特别是在大量栈扩展的情况下。
* 栈段的指针跳跃和管理比较复杂，且可能引发内存管理上的瓶颈。

#### 2. 连续栈（Contiguous Stack）

在 Go 1.5 引入 连续栈 模型后，每个`goroutine`的栈现在是 连续的，即栈空间是一个 连续的内存块。这种模型避免了栈段的分配和链式连接，使得内存管理更加高效。

如何改进：

* 栈的增长：goroutine 的栈大小初始时较小，通常是 2 KB。当栈空间不足时，Go 会动态地扩展栈空间，而不是为每个新的栈段分配一个新的内存区域。扩展时，新的栈空间会被分配成一个连续的内存块，并且栈的指针会指向新的内存块。
* 通过内存复制，栈的内容会被从旧栈位置复制到新的位置，从而保证栈的扩展是连续的。这种做法简化了栈的管理并提高了性能。

连续栈的优点：

* 减少内存分配：扩展栈时，不需要为每个栈段分配单独的内存区域，而是通过扩展栈的大小来保持栈的连续性。
* 避免内存碎片化：由于栈的空间是连续的，减少了内存碎片化的问题。
* 更简单的栈管理：操作系统的内存管理和 Go 的栈扩展机制变得更加简洁，减少了内存复制和重分配的开销。
* 性能提升：连续栈使得栈的扩展更加高效，减少了 Hot stack split 问题带来的性能瓶颈。

#### 3. Hot Stack Split 问题

"Hot stack split" 问题指的是在分段栈模型中，由于栈的扩展操作，需要频繁地分配新栈段并将现有栈内容复制到新栈段，导致了以下问题：

* 内存碎片：栈段分配和扩展可能导致内存的碎片化。
* 频繁的内存分配：频繁的栈扩展和栈段链接导致了大量的内存分配和释放操作，这会影响性能。
* 复杂的管理：分段栈模型的管理比连续栈复杂，栈段的拼接、指针的重定向和垃圾回收等操作都需要更多的资源。

通过将栈改为连续栈，Go 解决了这个问题：

* 只需要扩展一个连续的内存块，而不需要再进行栈段的拼接和内存管理。
* 因为栈的空间是连续的，所以内存分配变得更加高效，减少了内存碎片。
