# README

## 笔记

数据类型

* 基础类型
	* 数字
	* 字符串
	* 布尔
* 复合类型
	* 数组
	* 结构体
* 引用类型
	* 指针
	* 切片
	* 字典
	* 函数
	* 通道
* 接口类型

### 3.1 整型

`byte`与`uint8`等价

* `int8`: `-128`到`127`
* `unit8`: `0`到`255`

`%`取模模运 算符的符号和被取模数的符号总是一致的，因此 -5%3 和 -5%-3 结果都是-2。

除法运算 符 / 的行为则依赖于操作数是否为全为整数，比如 5.0/4.0 的结果是1.25，但是5/4的结果是 1，因为整数除法会向着0方向截断余数。

### 3.2 浮点数

为NaN和任何数都是不相等

### 3.3 复数

### 3.4 布尔型

布尔值并不会隐式转换为数字值0或1，反之亦然。

```
func btoi(b bool) int {
	if b {
		return 1
	}
	return 0
}

func itob(i int) bool { return i != 0 }
```

### 3.5 字符串

第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个 字节。

字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的。

不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。

一个原生的字符串面值形式是`...`，使用反引号代替双引号。在原生的字符串面值中，没有转 义操作；

Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类 型）。

通用的表示一个Unicode码点的数据类型是int32，也就是 Go语言中rune对应的类型；

`strconv`包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相 关的转换。

bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、 byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要初始化，因为零 值也是有效的。

当向bytes.Buffer添加任意字符的UTF8编码时，最好使用bytes.Buffer的WriteRune方法。

**格式互换**

* s := "abc"
*  b := []byte(s) 
*  s2 := string(b)

### 3.6 常量

iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不 用每行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行， iota将会被置为0，然后在每一个有常量声明的行加一。

