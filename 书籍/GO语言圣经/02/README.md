# README

## 笔记

### 2.1

如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义， 那么将在当前包的所有文件中都可以访问。

如果一个名字是大写字母开头的，那么它将是导出的。

### 2.2

* var: 变量
* const: 常量
* type: 类型
* func: 函数


在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，局部声明的名字就只能在函数内部 很小的范围被访问。

### 2.3 

初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前 完成初始化。

局部变量将在声明语句被执行到的时候完成初始化。

`名字 := 表达式`, 简短变量声明，变量的类型根据表达式来自动推导。

`var`形 式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初 始值无关紧要的地方。

**区别**

* `:=`, 是一个变量声明语句。
* `=`, 是一个变量赋值操作。

简短变量声明语句中必须至少要声明一个新的变量。

```
f, err := os.Open(infile) // 
... 
f, err := os.Create(outfile) // compile error: no new variables
```

简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量 是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。

#### 指针

一个指针对应变量在内存中的存储位置。

变量有时候被称为可寻址的值。

任何类型的指针的零值都是nil。

指针之 间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。

`new(T)`将创建一个T类型的匿名变 量，初始化为`T`类型的零值，然后返回变量地址，返回的指针类型为 `*T`。

```
p := new(int) // p, *int 类型, 指向匿名的 int 变量 
fmt.Println(*p) // "0" 
*p = 2 // 设置 int 匿名变量的值为 2 
fmt.Println(*p) // "2"
```

#### 垃圾收集

从每个包级的变量和每个当前运行函数的每一个局 部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访 问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。

### 2.5

一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类 型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。

```
type 类型名字 底层类型
```

**类型转换**

类型转换不 会改变值本身，但是会使它们的语义发生变化。

对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型。

只有当两个类型的底层基础类型 相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只 改变类型而不会影响值本身。

### 2.6

包导出：如果一个名字是大写字母开头的，那么该名字是导出的。

`init`初始化函数来简化初始化工作。

```
func init() { /* ... */ }
```

在每个文件中的 init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。

初始化 工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在`main`函数执行之 前，所有依赖的包都已经完成初始化工作了。

### 2.7

声明语句的作用域对应的是一个源代码的文本区域；它 是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时 间区域内它可以被程序的其他部分引用；是一个运行时的概念。

当编译器遇到一个名字引用时，如果它看起来像一个声明，它首先从最内层的词法域向全局 的作用域查找。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部 的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的 声明，让外部的声明的名字无法被访问。

一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。

Go语言的习惯是在if中处理错误然后直接返回，这样可以确保 正常执行的语句不需要代码缩进。