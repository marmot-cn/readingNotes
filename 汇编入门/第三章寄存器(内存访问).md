# 第三章寄存器(内存访问)

---

###笔记

---

#### 内存中的字存储

在 0 地址处开始存放 20000 (4E20H)

* 20 存低地址 0
* 4E 存高地址 1

**字单元和单元 字节型和字型**

* 0 地址`单元`存放的`字节型`数据是: 20
* 0 地址`字单元`存放`字型`数据是多少: 4E20

字型要考虑2个字节,高地址对应高位,低地址对应低位.

**结论**

任何两个地址连续的内存单元,N(低位) 号单元和 N+1(高位) 号单元,可以将它们看成两个内存单元,也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元.

#### DS 和 [address]

CPU 要读取一个内存单元的时候,必须要先给出这个内存单元的地址.

在 8086PC 中,内存地址由段地址和偏移地址组成.

8086CPU中有一个`DS`(`D`ata `S`egmant)寄存器,通常用来存放要访问的`数据的段地址`.

**示例**

		读取 10000H 单元的内容
		
		mov bx,1000H //段,所以会乘16 左移1位
		mv ds,bx
		mv al,[0]
		
		将 10000H(1000:0) 中的数据读到al中

**mov指令**

* 将数据直接送入寄存器 `mov ax,2`
* 将一个寄存器中的内容送入另一个寄存器 `mov bx,ax`
* 将一个内存单元中的内容送入一个寄存器
		
		将偏移地址位0的内容送入寄存器,根据段地址
		mov al,[0]


**从哪个内存单元送到哪个寄存器中**

		mov 寄存器名,内存单元地址
		
8086cpu不支持将数据直接送入段寄存器的操作,ds是一个段寄存器.只能直接送入通用寄存器.

		数据 -> 通用寄存器 -> 段寄存器

将数据从寄存器送入内存单元:
		
		
		mov bx,1000H
		mov ds,bx
		mov [0],al			
			
#### 字的传送

8086CPU是16位结构,有16根数据线,所以,可以一次性传送16位的数据,也就是一次性传送一个字.

		mov bx,1000H
		mov ds,bx
		mov ax,[0]  //将1000:0处的字型数据送入ax
		mov [0],cx  //将cx中的16位数据送到1000:0处

因为以前CPU是 `8` 位,所以用`字节`.
后来 `16` 位, 用`字`.
后来 `32` 位, 用 `双字`

#### mov,add,sub 指令

**mov**

		mov 寄存器, 数据 		mov ax,6
		mov 寄存器, 寄存器	mov bx,ax
		mov 寄存器, 内存单元 	mov ax,[0] (偏移地址)
		mov 内存单元, 寄存器	mov [0],ax
		mov 段寄存器, 寄存器	mov ds,ax
		
可以推导出

		mov 寄存器, 段寄存器	mov ax,ds
		
**add 和 sub**

		add 寄存器,数据		add ax,8
		add 寄存器,寄存器		add ax,bx
		add 寄存器,内存单元	add ax,[0]
		add 内存单元,寄存器	add [0],ax
		sub 寄存器,数据		sub ax,9
		sub 寄存器,寄存器		sub ax,bx
		sub 寄存器,内存单元	sub ax,[0]
		sub 内存单元,寄存器	sub [0],ax	

#### 数据段

我们可以根据需要将一组内存单元定义为一个段(可以使代码段,数据段等).

我们可以将一组长度为N(N<=64K),地址连续,其实地址为16倍数的内存单元当做专门存储数据的内存空间,从而定义了一个数据段.

		比如我们用123B0H ~ 123B9H这段空间来存放数据:
		段地址: 123BH 也可以吧段地址看做 1230
		长度: 10字节 (0~9)

如何访问数据段中的数据?

将一段内存当做数据段,使我们在编程时的一种安排,我们可以在具体操作的时候,用ds存储数据段的段地址,再根据需要,用相关质量访问数据段中的具体单元.

#### 栈

栈是一种具有特殊的访问方式的存储空间.它的特殊性就在于,最后进入这个空间的数据,最先出去.

**栈的基本操作**

* 入栈, 将一个新的元素放到栈顶.
* 出栈, 从栈顶取出一个元素.

LIFO, Last In First Out.
		
#### CPU提供的栈机制

**指令**

* `PUSH`, 入栈
* `POP`, 出栈

		push ax 将寄存器ax中的数据送入栈中.
		pop ax 从栈顶取出数据送入ax
		
8086CPU的入栈和出栈操作都是以字为单位进行的.
		
**CPU如何知道一段内存空间被当做栈使用?**

* 段寄存器`SS` 存放`栈顶`的段地址
* 寄存器`SP` 存放`栈顶`的偏移地址

任意时刻, SS:SP 指向栈顶元素.

**执行push和pop的时候,如何知道哪个单元是栈顶单元?**

当我们执行 push ax 时, CPU 内部执行了如下运算:

* SP = SP-2
* 将ax中的内容送入SS:SP指向的内存单元处,SS:SP此时指向新栈顶.

pop则是相反.

* 取出数据
* SP = SP+2

		pop ax
		1. 将 SS:SP 指向的内存单元处的数据送入(是复制不是剪切) ax 中.
		2. 将 SP = SP + 2, SS:SP 指向当前栈顶下面的单元,以当前栈顶下面的单元为新的栈顶


pop取出数据的时候,数据是存在的.下一次push会覆盖.类似硬盘格式化,数据还是存在的,只是硬盘头索引放生了变化. 一般粉碎工具就是不断重复的覆盖数据.

**当栈是空的时候,SP指向?**

10000H ~ 1000FH 这段空间当做栈,初始状态栈是空的.

SP 指向最高地址的下一个地址. 0010H (1000FH的下一个地址是 10010H).

#### 栈顶超界的问题

SS和SP只记录了栈顶的地址,依靠SS和SP可以保证入栈和出栈时找到栈顶.可是,如何能够保证在入栈和出栈时栈顶不会超出栈空间.

当栈满的时候再使用push指令入栈,栈空的时候再使用pop指令出栈,都将发生栈顶越界的问题.

栈顶越界一般就是我们说的溢出.

**栈顶超界是危险的**

因为我们既然将一段控件安排为栈(也就是我们认为这段空间是栈),那么在栈空间之外的空间里很可能存放了具有其他用途的数据,代码等,这些数据,嗲吗可能是我们自己的程序中的,也可能是别的程序中的.

**8086CPU不保证对栈的操作不会超界**

8086CPU 只知道栈顶在何处(由SS:SP指示),而不知道读者安排的栈控件有多大.这点就好像,CPU只知道当前要执行的指令在何处(由CS:SP指示)而不知道读者要执行的指令有多少.

可以得出, 8086CPU的工作机理,只考虑从当前的情况:

* 当前栈顶在何处
* 当前要执行的指令是哪一条

**结论**

我们在编程的时候要自己操心栈顶超界的问题,要根据可能用到的最大栈控件,来安排栈的大小,防止入栈的数据太多而导致的超界.出栈同理.

		我们在做C语言编程的时候,编译器会帮我们申请要栈空间,程序员自己申请的是堆.
		
`堆`是一堆连续的内存,线性表组成的.

#### push,pop指令

push 和 pop 指令是可以在寄存器和内存之间的传送数据的.

**栈与内存**

栈空间当然也是内存空间的一部分,它只是一段可以以一种特殊的方式进行访问的内存空间.

**指令格式:寄存器**

* push 寄存器
* pop 寄存器

**指令格式:段寄存器**

* push 段寄存器: 将一个段寄存器中的数据入栈.
* pop 段寄存器: 出栈,用一个段寄存器接收出栈的数据.

		push ds
		pop es

**指令格式:内存单元**

* push 内存单元: 将一个内存单元处的字入栈(栈操作都是以字为单位).
* pop 内存单元: 出栈,用一个内存单元接收出栈的数据.

		push [0]
		pop [2]

指令执行时,CPU要知道内存单元的地址,可以在 push,pop 指令中给出内存单元的偏移地址,段地址在指令执行时,CPU从`ds`中取得.

#### 栈段

###整理知识点

---

#### 函数局部变量

局部变量存在栈中,所以当函数出了栈,局部变量失效.